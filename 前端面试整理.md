title: 前端面试整理
author: azlar
date: '2017-08-10 10:22:54'
tags: [前端, 面试题, 面试, javascript, css]
ignore: true
auth: true

---
前端知识梳理
<!-- desc -->
# JS
## [http://markyun.github.io/2015/Front-end-Developer-Questions/#js](http://markyun.github.io/2015/Front-end-Developer-Questions/#js)

### 介绍JavaScript的基本数据类型
- String、Number、Boolean、数组、对象、Null、Undefined、Symbol（es6）
- 基本：Undefined、Null、Boolean、Number、String

### 说说写JavaScript的基本规范？

### JavaScript原型，原型链 ? 有什么特点？
#### 原型
1. 我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的
	```js
	function Foo() {}
	Foo.prototype = 1; // 无效
	```

2. 代码
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = {
		add: (x, y) => x + y,
		subtract: (x, y) => x - y
	};
	
	let t = new Calc();
	
	console.log(t.tax);
	//5
	```
	
	---
	
	```js
	const Calc = function () {
		this.decimalDigits = decimalDigits;
		this.tax = tax;
	};
	
	Calc.prototype = function () {
		add = (x, y) => x + y;
		subtract = (x, y) => x - y;
		
		return {
			add,
			subtract
		}
	}();
	
	let t = new Calc();
	console.log(t.subtract(-0.5, 1));
	//-1.5
	```

#### 原型链
1. 属性在查找的时候是先查找自身的属性，如果没有再查找原型，再没有，再往上走，一直查到 Object 的原型上：

	```js
    function foo() {
        this.add = function (x, y) {
            return x + y;
        }
    }

    foo.prototype.add = function (x, y) {
        return x + y + 10;
    }

    Object.prototype.subtract = function (x, y) {
        return x - y;
    }

    var f = new foo();
    alert(f.add(1, 2)); //结果是3，而不是13
    alert(f.subtract(1, 2)); //结果是-1
	```
	
2. `hasOwnProperty()` 与防止 `hasOwnProperty()` 被占用

	```js
	//1. hasOwnProperty
	Object.prototype.bar = 1; 
	var foo = {goo: undefined};
	
	foo.bar; // 1
	'bar' in foo; // true
	
	foo.hasOwnProperty('bar');	// false
	foo.hasOwnProperty('goo');	// true
	
	//2. user define hasOwnProperty()
	var foo = {
	    hasOwnProperty: function() {
	        return false;
	    },
	    bar: 'Here be dragons'
	};
	
	foo.hasOwnProperty('bar'); // 总是返回 false
	
	// 使用{}对象的 hasOwnProperty，并将其上下为设置为foo
	{}.hasOwnProperty.call(foo, 'bar'); // true
	
	```
	
3. ``__proto__``
	
	```js
	var A = function(){};
	var a = new A();
	console.log(a.__proto__); //A {}（即构造器function A 的原型对象）
	console.log(a.__proto__ === a.constructor.prototype); //true
	console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
	console.log(a.__proto__.__proto__.__proto__); //null
	
	/*
	Function.prototype = {
		constructor : Function,
		__proto__ : parent prototype,
		some prototype properties: ...
	};
	*/
	```
	
4. 链式继承模型
	
	```js
	function A(x) {
		this.x = x;	
	}
	A.prototype.a = "a";
	
	function B(x, y) {
		this.y = y;
		A.call(this, x);
	}
	B.prototype.b1 = function(){
		console.log("b1");
	}
	
	B.prototype = new A();
	B.prototype.b2 = function(){
		console.log("b2");
	}
	
	B.prototype.constructor = B;
	
	var obj = new B(1,3);
	console.log(obj);
	/*
	[object Object] {
		a: "a",
		b2: function () {
			window.runnerWindow.proxyConsole.log("b2");
		},
		constructor: function B(x, y) {
			this.y = y;
			A.call(this, x);
		},
		x: 1,
		y: 3
	}
	*/
	```	
5. `new A()`分解

	```js
	var Person = function(name) {
		this.name = name;
	}
	var p = new Person();
	
	// 分解为：
	var p = {}
	p.__proto__ = Person.prototype
	Person.call(p)
	```
6. 特点
> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
> 
> 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。


### JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？
> from: [http://blog.csdn.net/lxcao/article/details/52749421](http://blog.csdn.net/lxcao/article/details/52749421)

#### 两大类

> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）

> 堆：引用数据类型（对象、数组和函数）

#### 区别
两种类型的区别是：

- 存储位置不同；
- 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其
在栈中的地址，取得地址后从堆中获得实体。

#### 图
![](//blog.azlar.cc/images/frontend_interview/数据存储.png)

### Javascript如何实现继承？
class, proto chain, call。。只能想到这几个

摘抄一篇：

> from: [http://www.cnblogs.com/humin/p/4556820.html](http://www.cnblogs.com/humin/p/4556820.html)

#### 定义父类
```js
function Animal(name) {
	this.name = name || 'parent';

    this.sleep = function () {
        return this.name + ' is sleeping';
    }
}

Animal.prototype.eat = function(food) {
    return this.name + ' is eating ' + food;
};
```

##### 1. 原型链继承
核心：**将父类的实例作为子类的原型**

```js
function Cat() {}

Cat.prototype = new Animal();
Cat.prototype.name = 'cat';

var cat = new Cat();
console.log(cat.name);	//cat
console.log(cat.eat('fish'));	//cat is eating fish
console.log(cat.sleep());	//cat is sleeping
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

特点：

	1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
	2. 父类新增原型方法/原型属性，子类都能访问到
	3. 简单，易于实现

缺点：
	
	1. 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
	2. 无法实现多继承
	3. 来自原型对象的引用属性是所有实例共享的（详细请看附录代码：示例1）
	4. 创建子类实例时，无法向父类构造函数传参

推荐指数：★★（3、4两大致命缺陷）


示例1:

```js
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
  //实例引用属性
  this.features = [];
}
function Cat(name){
}
Cat.prototype = new Animal();

var tom = new Cat('Tom');
var kissy = new Cat('Kissy');

console.log(tom.name); // "Animal"
console.log(kissy.name); // "Animal"
console.log(tom.features); // []
console.log(kissy.features); // []

tom.name = 'Tom-New Name';
tom.features.push('eat');

//针对父类实例值类型成员的更改，不影响
console.log(tom.name); // "Tom-New Name"
console.log(kissy.name); // "Animal"
//针对父类实例引用类型成员的更改，会通过影响其他子类实例
console.log(tom.features); // ['eat']
console.log(kissy.features); // ['eat']
```
原因分析：

关键点：属性查找过程

执行tom.features.push，首先找tom对象的实例属性（找不到），
那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的
features属性中插入值。
在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。
刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。

##### 2. 构造继承
核心：**使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：

	1. 解决了1中，子类实例共享父类引用属性的问题
	2. 创建子类实例时，可以向父类传递参数
	3. 可以实现多继承（call多个父类对象）

缺点：

	1. 实例并不是父类的实例，只是子类的实例
	2. 只能继承父类的实例属性和方法，不能继承原型属性/方法
	3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
	
推荐指数：★★（缺点3）


##### 3. 实例继承
核心：**为父类实例添加新特性，作为子类实例返回**

```js
function Cat(name){
  var instance = new Animal();
  instance.name = name || 'Tom';
  return instance;
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // false
```

特点：

	1. 不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果

缺点：

	1. 实例是父类的实例，不是子类的实例
	2. 不支持多继承

推荐指数：★★

##### 4. 拷贝继承
```js
function Cat(name){
  var animal = new Animal();
  for(var p in animal){
    Cat.prototype[p] = animal[p];
  }
  Cat.prototype.name = name || 'Tom';
}

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
```

特点：

	1. 支持多继承

缺点：

	1. 效率较低，内存占用高（因为要拷贝父类的属性）
	2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）


推荐指数：★（缺点1）


##### 5. 组合继承
核心：**通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
```

特点：
	
	1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
	2. 既是子类的实例，也是父类的实例
	3. 不存在引用属性共享问题
	4. 可传参
	5. 函数可复用

缺点：

	1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）

推荐指数：★★★★（仅仅多消耗了一点内存）

		
##### 6. 寄生组合继承
核心：**通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点**

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();

// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
```
**堪称完美**

缺点：
	
	1. 实现较为复杂

推荐指数：★★★★（实现复杂，扣掉一颗星）



### Javascript创建对象的几种方式？
```js
let oa = {};


let ob = new Object();


function ObjectC() {}

let oc = new ObjectC();
oc.a = 123;
oc.foo = () => {};


function ObjectD(name, sex, something = '') {
	this.name = name;
	this.sex = sex;
	this.something = something || null;
	
	this.do = function () {
		console.log(this.name + "is doing " + this.something);
	}
}

let od = new ObjectD("azlar", 1, "homework");
od.do();

function ObjectE() {}
ObjectE.prototype.name = "azlar";
ObjectE.prototype.sex = 1;

let oe = new ObjectE();

//other 混合模式(原型和构造函数)
function Car(name,price){  
  this.name=name;  
  this.price=price;   
}  
 Car.prototype.sell=function(){  
   alert("我是"+this.name+"，我现在卖"+this.price+"万元");  
  }  
  
var camry =new Car("凯美瑞",27);  
camry.sell();   

//动态原型的方式(可以看作是混合模式的一种特例)
function Car(name,price){  
  this.name=name;  
  this.price=price;   
  if(typeof Car.sell=="undefined"){  
   Car.prototype.sell=function(){  
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");  
   }  
 Car.sell=true;  
  }  
}  
  
var camry =new Car("凯美瑞",27);  
camry.sell();  

```

### Javascript作用链域?
#### 作用域
js 没有块级作用域，只有函数作用域。

另：js 中未使用 `var` 声明的变量都是全局变量，且可被 `delete` 删除：

```js
s = 123;
var a = 123;
delete s;

console.log(s, a);
//ReferenceError: s is not defined
```

#### 作用域链
```
name="lwy";
function t(){
    var name="tlwy";
    function s(){
        var name="slwy";
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
console.log(name);

//slwy
//tlwy
//lwy
```

> from: [https://community.risingstack.com/explaining-javascript-closure-scope-chain-examples/](https://community.risingstack.com/explaining-javascript-closure-scope-chain-examples/)
> 
> **When a variable is used, the program traverses the scope chain until it finds an entry for that variable. Redeclaring a variable or passing it into a function is a way of separating it from its previous existence in the scope chain.**
> 
> ```js
> var str1 = 'hello';  
> //Redeclaring the variable
> var str2 = str1;  
> str1 = 'goodbye';  
> //Redeclaring the variable has separated it from its original reference
> console.log(str2);//hello
> 
> var str1 = 'hello';  
> var printVar = function(v){  
>     return function(){
>         console.log(v);
>     };
> };
> //Passing in variable into a function
> var printHello = printVar(str1);
> str1 = 'goodbye';  
> //Passing the variable into a function has saved it in the function's scope
> printHello();//hello
> ```
> 

一些例子：

```js
//Even though the name of the variable is the same, we are using the
//value that is passed into the function, not the value that keeps incrementing
var logI = function(i){  
    return function(){
        console.log(i);
    };
};

for (var i = 0; i < 10; i++){  
    setTimeout(logI(i), 1000);
}

//or

var logI = function(i){
    // return function(){
        console.log(i);
    // };
};

for (var i = 0; i < 10; i++){
    setTimeout(logI.bind(this, i), 1000);
}


//result: 0 1 2 3 4 5 6 7 8 9
```

> from: [http://ryanmorr.com/understanding-scope-and-context-in-javascript/](http://ryanmorr.com/understanding-scope-and-context-in-javascript/)
> 
> ```js
> function first() {
> 	second();
> 		function second() {
> 			third();
>        	function third() {
>             fourth();
>             function fourth() {
>                 // do something
>             }
>         }
>     }   
> }
> first();
> ```
> 
> Running the preceding code will result in the nested functions being executed all the way down to the `fourth` function. At this point the scope chain would be, from top to bottom: fourth, third, second, first, global. The `fourth` function would have access to global variables and any variables defined within the `first`, `second`, and `third` functions as well as the functions themselves.

> Name conflicts amongst variables between different execution contexts are resolved by climbing up the scope chain, moving locally to globally. This means that local variables with the same name as variables higher up the scope chain take precedence.

> To put it simply, each time you attempt to access a variable within a function’s execution context, the look-up process will always begin with its own variable object. If the identifier is not found in the variable object, the search continues into the scope chain. It will climb up the scope chain examining the variable object of every execution context looking for a match to the variable name.




### 谈谈This对象的理解。
this 指的是当前对象。


调用形式	| this指向 
--------- | -------- 
普通函数	| window
构造函数 | 实例化后的对象
对象的方法 | 该对象
DOM 节点 | 该节点对象
call 或者 apply | 第一个参数


#### arrow function
> arrow function: Until arrow functions, every new function defined its own this value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.).
> 
> 另：
> 
> 1. 有对象就指向调用对象
> 2. 没调用对象就指向全局对象
> 3. 用 new 构造就指向新对象
> 4. 通过 apply 或 call 或 bind 来改变 this 的指向

### eval是做什么的？
类似与 linux 的 exec，将字符串作为代码执行。

缺点：

1. 可读性非常差
2. 不好再做优化和编译
3. 会轻微增加性能消耗
4. 不安全，比如 eval input 的值

偶尔也可以用一下，比如写一些需要使用动态变量替换的复杂式时。

### 什么是window对象? 什么是document对象?
window 是一个顶层对象，即当前窗口。

document 对象是 window(frames) 的一个属性，包含 HTML 在内的需渲染的内容。

详细可以看下这里：[https://stackoverflow.com/questions/9895202/what-is-the-difference-between-window-screen-and-document-in-javascript](https://stackoverflow.com/questions/9895202/what-is-the-difference-between-window-screen-and-document-in-javascript)


### null，undefined的区别？
*null* 表示一个变量的值，表示 `no value`。

*undefined* 表示未声明，或未被赋值（declared）。

```js
var a;

console.log(a)	//undefined
console.log(typeof a)	//undefined
```

```js
var a = (undefined = 'abc');
console.log(a);

//abc
//当代码处于 'use strict' 严格模式时，undefined 变为只读，会报错。
//null = 'abc'; =>	ReferenceError: Invalid left-hand side in assignment
```

### 写一个通用的事件侦听器函数(机试题)。
```js
//todo
```

### ["1", "2", "3"].map(parseInt) 答案是多少？
```js
["1", "2", "3"].map(parseInt);

//=>

["1", "2", "3"].map((v, index) => parseInt(v, index));

/*
parseInt("1", 0);
parseInt("2", 1);
parseInt("3", 2);
[0]=parseInt(“1”,0);	//1*100=1*1=1

[1]=parseInt(“2”,1);	//radix不在2~36的返回NaN

[2]=parseInt(“3”,2);	//二进制数没有3，只有0 1 ，所以NaN 
*/
```

### 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？
区别：不知

阻止冒泡：`e.stopPropagation();`

#### 补充
1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为
2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件
3. ev.stopPropagation();注意旧ie的方法：ev.cancelBubble = true;


### 什么是闭包（closure），为什么要用它？
1. 闭包是为了让一个程序内的私有变量变得可访问，类似于后端语言内的 getPrivateVariable()。
2. 让变量的值保存与内存中。
	```js
	let add;
	function a() {
		let b = 2;
	
		add = () => { b++ };
		
		return () => console.log(b);
	}
	
	let x = a();
	x();	//2
	
	add();
	
	x();	//3
		
	```

#### 补充
> 垃圾回收：一般来说,一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.
> 

```js
var result=[];
function foo(){di
    var i= 0;
    for (;i < 3;i = i+1){
        result[i] = function () {
            console.log(i)
        }
    }
};
foo();
result[0](); // 3
result[1](); // 3
result[2](); // 3

//*********
//可修改为：

result[i] = (x => function(){
    console.log(x)
})(i)

```

### javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？
严格模式，js 本身的容错率很高，有点像 php，区别：未声明的变量会报错，很多（不严谨）操作会报错。

#### 补充
#### google：
> Strict mode helps out in a couple ways: 
> 
> * It catches some common coding bloopers, throwing exceptions. 
> * It prevents, or throws errors, when relatively "unsafe" actions are taken (such as gaining access to the global object). 
> * It disables features that are confusing or poorly thought out.

可以只针对部分代码使用严格模式：

```javascript
// Non-strict code...

(function(){
  "use strict";

  // Define your library strictly...
})();

// Non-strict code... 
```

#### 区别
> from: [http://jsmean.com/blog/post/55a9db88a0367a75336e8884](http://jsmean.com/blog/post/55a9db88a0367a75336e8884)


##### 变量限制
###### 未定义限制

```javascript
"use strict"
a = 123;
	
// ReferenceError: a is not defined
```
###### 1. 名称限制
	```javascript
	//1. eval & arguments
	var arguments = 10;
	var eval=10;

	// SyntaxError: Unexpected eval or arguments in strict mode
	
	/*
	2. reserved word
	implements
	interface
	package
	private
	protected
	public
	static
	yield
	
	//SyntaxError: Unexpected strict mode reserved word
	*/
	```
	
##### 2. 自定义对象的限制
###### 只读属性
一般情况下，我们是不需要自定义对象的属性的，但是如果我们分配了一个对象的内容为只读，当我们后面调用赋值语句时，非严格模式不会自动报错，但也不会执行赋值操作，所以下面的语句

```javascript
"use strict";

let obj = {};
Object.defineProperties(obj, {
    'property1': {
        value: "123",
        writable: true
    },
    'property2': {
        value: 'Hello',
        writable: false
    }
    // etc. etc.
});

obj.property1 = 22222;
obj.property2 = 22222;

console.log(obj.property1);
console.log(obj.property2);

// 非严格模式下：obj.property2 的值不会被改变，但不会报错
// 严格模式下：TypeError: Cannot assign to read only property 'property2' of object '#<Object>'
```

附：[defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)

###### 扩展属性
如果需要阻止对象扩展，按照如下的操作进行后，在非限制模式下不报错，但是输出为 underfine

```javascript
var testObj = new Object();

Object.preventExtensions(testObj);

testObj.name = "Bob";
console.log(testObj.name);

//非严格模式下：underfined,不报错
//严格模式下：TypeError: Can't add property name, object is not extensible
```

附：[preventExtensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)

###### 配置属性
当我们尝试去删除一个 `configurable: false` 的对象,不同模式下会产生什么样的情况呢？

```javascript
"use strict";

let obj = {};
Object.defineProperties(obj, {
    'property1': {
        value: "123",
        writable: true
    },
    'property2': {
        value: 'Hello',
        writable: false,
        configurable: false
    }
    // etc. etc.
});

delete obj.property2;

// 非严格模式下：不删除 property2 属性，也不会报错
// 严格模式下：TypeError: Cannot delete property 'property2' of #<Object>
```

###### 重复属性
```javascript
var testObj = {
    prop1: 10,
    prop2: 15,
    prop1: 20
};

console.log(testObj.prop1);  //20  非严格模式下
console.log(testObj.prop2);      //15  非严格模式下

//严格模式下：SyntaxError: Duplicate data property in object literal not allowed in strict mode
```

##### 3. 函数对象的严格模式
###### 函数参数
不能修改函数体内 arguments 的值，来直接修改传递到函数的参数值。

```javascript
function test (argList) {
//    'use strict';
    
    arguments[0] = 100;
    arguments[1] = 100;
    
    console.log(arguments);
    console.log(argList);
}
test(10);

//非严格模式下的输出 { '0': 100, '1': 100 }  100
//严格模式下的输出 { '0': 100 }  10  
```

###### 参数参数调用 callee
```javascript
(function (testInt) {
    if (testInt-- == 0)
        return;
    else{
        console.log(testInt);
    }
    arguments.callee(testInt--);
})(10);
//输出内容：9，8，7，6，5，4，3，2，1，0
//严格模式下输出：TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
```

关于 callee，caller：
[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

1. callee: 用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也称为“匿名函数”)内。
	```javascript
	// return 1 * 2 * (...) * n
	function factorial (n) {
   		return !(n > 1) ? 1 : factorial(n - 1) * n;
	}
	[1,2,3,4,5].map(factorial);

	// vs
	
	[1,2,3,4,5].map(function (n) {
   		return !(n > 1) ? 1 : arguments.callee(n - 1) * n;
	});
	```

2. arguments.caller: 已被废弃，原先用在函数执行的时候调用自身。

##### 4. with 的使用限制
with 本身是个非常不高效的 javascript 用法，当然他的确可以简化内部调用的代码编写，但是如果 with 代码块中包含了非对象所有的函数或者对象属性，他也会在其中进行查找。除非你能确保的确不存在重名的属性。

```javascript
var testObj={
    name:"mike",
    address:"Beijing"
}

var sayHello="hello my name is Z";
with(testObj){
    console.log(name);
    console.log(sayHello);  //hello my name is Z
}
testObj.sayHello=" Hello my name is Mike";

with(testObj){
    console.log(name);
    console.log(sayHello);  
   //Hello my name is Mike
}
```
上述中代码由于包含了一些重复名称的属性，可能是过程中修改了，添加了一些属性。导致在调用的时候无法真正的预测实际的输出是什么。

##### 5. this 的限制
当在一个函数中未定义 this 对象时在非严格模式下 将会返回 global 对象，而在严格模式下则为 underfined

```javascript
var fun=function(){
    return this;
}
console.log(fun());

// 非严格模式：依据环境不同返回不同的全局变量
// 严格模式下：underfined
```

##### 6. eval 的执行限制
```javascript
eval("var a = 10");
console.log(a);

// 严格模式下未定义
// 非严格模式下：10
```

注意，不是说 `eval` 不能用，而是指其与外界域无关：

>  In strict mode `eval` creates variables only for the code being evaluated, so `eval` can't affect whether a name refers to an outer variable or some local variable:

```javascirpt
var x = 17;
var evalX = eval("var x = 42; x;");

eval("console.log(x)");
console.log(x, evalX);
console.log(x === 17);
console.log(evalX === 42);

// 17
// 17 42
// true
// false
```

##### 7. 语句块中定义函数
对于语句块中定义的函数在严格模式是被限制使用的。

```javascript
var arr = [1, 2, 3, 4, 5];
var index = null;
for (index in arr) {
    function myFunc() {console.log(10);};
    myFunc()
}
// 非严格模式：10，10，10，10，10
// 严格模式：SyntaxError: In strict mode code, functions can only be declared at top level or immediately within another function.
```

**注，此条实测失败，在严格模式下是可以使用的。**

##### 8. delete plain name （补）
```javascript
//"use strict";

let x = 123;

delete x;
console.log(x);

// 非严格模式下，会输出 123
// 严格模式下：SyntaxError: Delete of an unqualified identifier in strict mode.
```

### 如何判断一个对象是否属于某个类？
```js
console.log([] instanceof Object);	//true
```

### new 操作符具体干了什么呢?
```javascript
var Person = function(name) {
	this.name = name;
}
var p = new Person();
	
// 分解为：
var p = {}
p.__proto__ = Person.prototype
Person.call(p)
```

另：[https://stackoverflow.com/questions/9468055/what-does-new-in-javascript-do-anyway](https://stackoverflow.com/questions/9468055/what-does-new-in-javascript-do-anyway)

```javascript
// new f(a, b, c)

// Create a new instance using f's prototype.
var newInstance = Object.create(f.prototype),	// var newInstance = new Object(); newInstance.__proto__ = f.prototype;
	result;

// Call the function
result = f.call(newInstance, a, b, c),

// If the result is a non-null object, use it, otherwise use the new instance.
result && typeof result === 'object' ? result : newInstance
```

步骤：

```javascript
var Func = function(){};  
var func = new Func ();  
```

1. 创建一个空对象：`var obj=new Object();`
2. 设置原型链：`obj.__proto__= Func.prototype;`
3. 让 Func 中的 this 指向 obj，并执行 Func 的函数体：`var result = Func.call(obj);`
4. 判断Func的返回值类型：如果是值类型，返回 obj。如果是引用类型，就返回这个引用类型的对象。
```javascript
if (typeof result == "object"){  
	func = result;  
}  
else{  
	func=obj;;  
}
```

### 用原生 JavaScript 的实现过什么功能吗？
仿写一些 jquery 的函数。

### Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
`hasOwnProperty()`，此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

### 对 JSON 的了解？
json 简单来说就是 js 中的对象与数组，传输时，即为字符串。

与 php 通信时，由于 php 数组与对象没有明确的区分（实际有，只是有些开发者不知道，会做出 `[2, "2" => 12, 3]` 这样的数据），所以一般当对象来解析（实际上直接分析即可，列出此点是由于之前项目里有同学把 json 直接当 数组处理，导致报错）。

### [].forEach.call($$("*"),function(a){ a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16) }) 
直观上来说，是为所有的元素加上一个 `outline`。

#### 补充分析
##### 1. $$
> from: [https://stackoverflow.com/questions/35682890/double-dollar-vs-dollar-sign-in-chrome-console-behavior](https://stackoverflow.com/questions/35682890/double-dollar-vs-dollar-sign-in-chrome-console-behavior)
> 
> 1. $() Returns the first element that matches the specified CSS selector. It is a shortcut for document.querySelector().
>
> 2. $$() Returns an array of all the elements that match the specified CSS selector. This is an alias for document.querySelectorAll()
>
> 3. $x() Returns an array of elements that match the specified XPath.


##### 2. (~~(Math.random()*(1<<24))).toString(16)
1. `a << b`：shifts a in binary representation b (< 32) bits to the left, shifting in zeroes from the right.
2. `~a`：反转操作数的比特位，即0变成1，1变成0。(~1 = -2, ~-2 = 1)
3. `~~`：可用来取整
4. `toString(radix)`：可转换为 2~36 内任意进制的数据。

可以全记下来，快速生成 16 进制色值。。。![](//blog.azlar.cc/images/emoji/facepalm.jpg)

### js 延迟加载的方式有哪些？
能想到的：

1. document.createElement("script")，类似跨域
2. `<script type="text/javascript" defer="defer">` (ie)

#### 补充
1. ifame
2. `<script type="text/javascript" src="demo_async.js" async="async"></script>`
3. ajax + eval
4. `document.write("<script type='text/javascript' src={file}></script>")`

### Ajax 是什么? 如何创建一个 Ajax？
即：Asynchronous Javascript And XML。

```javascript
var xhr = new XMLHttpRequest(),
	url,
	async = true;

xhr.open("POST", url, async);

xhr.onload = function () {
	if(xhr.status === 200) {
		console.log(xhr.response);
	}
}

xhr.onerror = function (err) {
	console.error(err);
}

xhr.send();
```

### 同步和异步的区别?
异步一般使用回调，同步一般会等待执行完成。


### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？
### Javascript创建对象的几种方式？

## self
### `call()` & `applay()`
> from: [http://uule.iteye.com/blog/1158829](http://uule.iteye.com/blog/1158829)

#### call
语法：`call([thisObj[, arg1[, arg2[,   [, .argN]]]]])`

定义：调用一个对象的一个方法，以另一个对象替换当前对象。 

说明：`call` 方法可以用来代替另一个对象调用一个方法。`call` 方法可将一个函数的对象上下文从初始的上下文改变为由 `thisObj` 指定的新对象。
如果没有提供 `thisObj` 参数，那么 *Global* 对象被用作 `thisObj`。

#### apply
语法：`apply([thisObj[, argArray]])` 

定义：应用某一对象的一个方法，用另一个对象替换当前对象。 

说明：如果 `argArray` 不是一个有效的数组或者不是 *arguments* 对象，那么将导致一个 TypeError。 
如果没有提供 `argArray` 和 `thisObj` 任何一个参数，那么 *Global* 对象将被用作 `thisObj`， 并且无法被传递任何参数。

#### code
a. 

```js
function add(x, y) { 
	console.log(x + y);
}
	
function sub(x, y) {
	console.log(x - y);
}
	
add.call(sub, 3, 1);	// 4
// add.call(sub,3,1) == add(3,1) 
```
b. 

```js
function Animal() {
    this.name = 'Animal';
    this.showName = function() {
        console.log(this.name)
    }
}
	
function Cat() {
    this.name = 'Cat';
}
	
let animal = new Animal(),
    cat = new Cat();
	
animal.showName.call(cat);	// Cat
//animal.showName.apply(cat); // Cat
```

c. 实现继承

```js
function Animal(name){
    this.name = name;
    this.showName = function(){
        console.log(this.name);
    }
}
    
function Cat(name){
    Animal.call(this, name);
}

var cat = new Cat("Black Cat");
cat.showName();	// Black Cat
```

d. 多重继承

```js
function Class10()
{
    this.showSub = function(a,b)
    {
        console.log(a - b);
    }
}

function Class11()
{
    this.showAdd = function(a,b)
    {

        console.log(a + b);
    }
}

function Class2()
{
    Class10.call(this);
    Class11.call(this);
}

let t = new Class2();

t.showAdd(1, 2);
```

### 变量提升
### 获取 scrollbar 宽高
法一：

```js
function getScrollBarWidth () {
    var inner = document.createElement('p);
    inner.style.width = "100%";
    inner.style.height = "200px";

    var outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild (inner);

    document.body.appendChild (outer);
    var w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var w2 = inner.offsetWidth;
    if (w1 == w2) w2 = outer.clientWidth;

    document.body.removeChild (outer);

    return (w1 - w2);
};
```

法二：

```js
//确定 div1 已有 scrollBar 的情况下（若没有需要像法一一样生成）：

let div1 = document.getElementById("div1");

let scrollBarWidth = parseInt(div1.getBoundingClientRect().width) - parseInt(window.getComputedStyle(div1).width);

//same as
//let scrollBarWidth = div1.offsetWidth - div1.clientWidth;
```

### range(0, n) 中间缺少一个
法一：

当 n 不是很大的时候，直接对其 reduce 求和，之后再根据数学公式求和 `sum(1, ...n)`，即可。

```js
let arr = range(1, n);
let sum = arr.reduce((a, b) => a + b, 0);
let realSum = n * (n + 1) / 2;

let x = realSum - sum;
```

法二：
将 range 中所有的数字异或，之后循环 arr，与每一个异或，最后求出所求。

法三：
排序后，循环比对。

### Map vs Object
具体参考：[https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/](https://blog.azlar.cc/article/JavaScript-Object-%E4%B8%8E-Map-%E6%AF%94%E8%BE%83/)

此处只列出我想到的。。

1. Map 的 key 可以为任意结构，而 Object 的 key 只能为 string
2. Map 有 `size()` 可以直接获得长度，Object 需要计算。
3. 。。。


### 常用排序、复杂度
冒泡、希尔、快排、插入排序

#### 冒泡
```js
function bubbleSort(array){
	var len = array.length,i,j, d;
	for(i=len;i--;){
		for(j=0; j<i; j++){
			var z = j+1;
			if(array[j] > array[z]){
				d = array[j];
				array[j] = array[z];
				array[z] = d;
			}
		}
	}
	return array;
}

```

#### 快速排序
基本思想：

1. 选择一个基准元素,通常选择第一个元素或者最后一个元素,
2. 通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。
3. 此时基准元素在其排好序后的正确位置
4. 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

```js
function quickSort(array){
	if(array.length == 0){
		return array;
	}
	var i = 0;
	var j = array.length - 1;
	var Sort = function(i, j){
	
		// 结束条件
		if(i == j ){ 
			return; 
		};
		
		var key = array[i];
		var stepi = i; // 记录开始位置
		var stepj = j; // 记录结束位置
	
		while(j > i){
			// j <<-------------- 向前查找
			if(array[j] >= key){
				j--;
			}else{
				
				array[i] = array[j]
				//i++ ------------>>向后查找
				while(j > ++i){
					if(array[i] > key){
						array[j] = array[i];
						break;
					}
					
				}
			}

		}
		
		// 如果第一个取出的 key 是最小的数
		if(stepi == i){
			Sort(++i, stepj);
			return ;
		}
		
		// 最后一个空位留给 key
		array[i] = key;
		
		
		// 递归
		Sort(stepi, i);
		Sort(j, stepj);
	}
	
	Sort(i, j);
	
	return array;
}
```

#### 插入排序
时间复杂度：O（n^2）
```js
function insertSort(array){

	var i = 1, j, step, key,
		len = array.length;
	//二分法
	var fun2f = function(a, b) {
		return Math.floor((a + b) / 2)
	}
	for(; i < len; i++){
		step = j = i;
		key = array[j];
		var b=0,e=i,
			z = fun2f(b, e)
		// while(--j > -1){
		// 	if(array[j] > key){
		// 		array[j+1] = array[j];
		// 	}else{
		// 		break;
		// 	}
		// }
		while (z != b) {
			if (key < array[z]) {
				e = z;
			} else {
				b = z;
			}
			z = fun2f(b, e);
		}
		z += key < array[z] ? 0 : 1;
		array.splice(z, 0, array.splice(i, 1)[0]);
	}
	
	return array;
}
```

#### 希尔排序
```js
function shellSort(array){

	var stepArr = [1031612713, 217378076, 45806244, 9651787, 2034035, 428481, 90358, 19001, 4025, 1750, 836, 701, 301, 132, 57, 23, 10, 4, 1]; // reverse() 在维基上看到这个最优的步长 较小数组
	var i = 0;
	var stepArrLength = stepArr.length;
	var len = array.length;
	var len2 =  parseInt(len/2);
	
	for(;i < stepArrLength; i++){
		if(stepArr[i] > len2){
			continue;
		}
		stepSort(stepArr[i]);
	}
	// 排序一个步长
	function stepSort(step){
		
		//console.log(step) 使用的步长统计
		
		var i = 0, j = 0, f, tem, key;
		
		
		for(;i < step; i++){// 依次循环列
			for(j=1; step * j + i < len; j++){//依次循环每列的每行
				tem = f = step * j + i;
				key = array[f];
				while((tem-=step) >= 0){// 依次向上查找
					if(array[tem] > key){
						array[tem+step] = array[tem];
					}else{
						break;
					}
				}
				array[tem + step ] = key;
			}
		}
		
	}
	
	return array;
	
}
```

#### 选择排序
```js
function selectionSort(array){
	var len = array.length;
	var index = 0;
	var k;
	var item;
	var c;
	for(var i=0; i<len; i++){
		
		item = array[i];
		index = i;
		//寻找最小的数位置
		for(j=i+1; j<len;j++){
			if(array[j] < item){
				index = j;
				item = array[j];
			}
		}
		if(index != i){
			c = array[i];
			array[i] = array[index];
			array[index] = c;
		}
	}
	return array;
}
```



### webpack chunk + react router

### isArray
```js
function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]';
}

//string
function isString(str){
    return Object.prototype.toString.call(str) === '[object String]';
}

```

#### 其他检测
```
let is ={
    types : ["Array", "Boolean", "Date", "Number", "Object", "RegExp", "String", "Window", "HTMLDocument"]
};
for(let i = 0, c; c = is.types[i ++ ]; ){
    is[c] = (function(type) {
        return function (obj) {
            return Object.prototype.toString.call(obj) === "[object " + type + "]";
        }
    })(c)
}
console.log(is.Array([])); // true
console.log(is.Date(new Date)); // true
console.log(is.RegExp(/reg/ig)); // true
```

### `$.extend()` vs `Object.assign()`

### 文档回流与重绘
> from: [http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/](http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)

#### 回流与重绘
> from [https://www.html.cn/archives/4996](https://www.html.cn/archives/4996)
> 
> 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

> 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

> 注意：**回流必将引起重绘，而重绘不一定会引起回流。**




#### 触发回流的操作
1. 调整窗口大小（Resizing the window）
2. 改变字体（Changing the font）
3. 增加或者移除样式表（Adding or removing a stylesheet）
4. 内容变化，比如用户在input框中输入文字（Content changes, such as a user typing text in
an input box）
5. 激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)（Activation of CSS pseudo classes such as :hover (in IE the activation of the pseudo class of a sibling)）
6. 操作 class 属性（Manipulating the class attribute）
7. 脚本操作 DOM（A script manipulating the DOM）
8. 计算 offsetWidth 和 offsetHeight 属性（Calculating offsetWidth and offsetHeight）
9. 设置 style 属性的值 （Setting a property of the style attribute）

#### TBD..

### `==` vs `===`
#### `==`
```js
console.log('a' == true);
console.log('a' == false);
	
console.log(123 == true);
console.log(123 == false);
	
console.log([] == true);
console.log([] == false);	//true
	
console.log({} == true)
console.log({} == false);
	
console.log([0] == false);	//true
console.log([0] == true);	//false
	
console.log(false == null);	//false
console.log(true == null);	//false
	
console.log([] == false);	//true
if([]) {
    console.log(2);	//reached here
}

console.log(NaN == NaN);	//false
	
```
	
此处要注意与 php 的混淆：
	
```php
echo 123 == true;	//1
echo 'abc' == true;	//1
	
echo [0] == true;	//1
echo false == null;	//1
```
	
#### `if(x)` 与 `x == true` 不同
> from: [https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true](https://stackoverflow.com/questions/23061921/javascript-ifx-vs-ifx-true)
> 
> if(x):
	
	+-----------------------------------------------------------------------+
	| Argument Type | Result                                                |
	|:--------------|------------------------------------------------------:|
	| Undefined     | false                                                 |
	|---------------|-------------------------------------------------------|
	| Null          | false                                                 |
	|---------------|-------------------------------------------------------|
	| Boolean       | The result equals the input argument (no conversion). |
	|---------------|-------------------------------------------------------|
	| Number        | The result is false if the argument is +0, −0, or NaN;|
	|               | otherwise the result is true.                         |
	|---------------|-------------------------------------------------------|
	| String        | The result is false if the argument is the empty      |
	|               | String (its length is zero); otherwise the result is  |
	|               | true.                                                 |
	|---------------|-------------------------------------------------------|
	| Object        | true                                                  |
	+-----------------------------------------------------------------------+

#### **文档**
	
> from: [[http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3)]([http://es5.github.io/#x11.9.3](http://es5.github.io/#x11.9.3))
>
> **11.9.3 The Abstract Equality Comparison Algorithm**
>
> The comparison *x* == *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:

> 1. If Type(*x*) is the same as Type(*y*), then

>	1. If Type(*x*) is Undefined, return **true**.
>	2. If Type(*x*) is Null, return **true**.
>	3. If Type(*x*) is Number, then

>		1. If *x* is **NaN**, return **false**.
>		2. If *y* is **NaN**, return **false**.
>		3. If *x* is the same Number value as *y*, return **true**.
>		4. If *x* is **+0** and *y* is **−0**, return **true**.
>		5. If *x* is **−0** and *y* is **+0**, return **true**.
>		6. Return **false**.

>	4. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return **false**.
>	5. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**. Otherwise, return **false**.
>	6. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.

> 2. If *x* is **null** and *y* is **undefined**, return **true**.
> 3. If *x* is **undefined** and *y* is **null**, return **true**.
> 4. If Type(*x*) is Number and Type(*y*) is String, return the result of the comparison *x* == ToNumber(*y*).
> 5. If Type(*x*) is String and Type(*y*) is Number, return the result of the comparison ToNumber(*x*) == *y*.
> 6. If Type(*x*) is Boolean, return the result of the comparison ToNumber(*x*) == *y*.
> 7. If Type(*y*) is Boolean, return the result of the comparison *x* == ToNumber(*y*).
> 8. If Type(*x*) is either String or Number and Type(*y*) is Object, return the result of the comparison *x* == ToPrimitive(*y*).
> 9. If Type(*x*) is Object and Type(*y*) is either String or Number, return the result of the comparison ToPrimitive(*x*) == *y*.
> 10. Return **false**.

> **Note 1**:		Given the above definition of equality

>	* String comparison can be forced by: **"" + a == "" + b**.
>	* Numeric comparison can be forced by: **+a == +b**.
>	* Boolean comparison can be forced by: **!a == !b**.

> **Note 2**:		The equality operators maintain the following invariants:

>	* **A != B** is equivalent to **!(A == B)**.
>	* **A == B** is equivalent to **B == A**, except in the order of evaluation of **A** and **B**.

> **Note 3**:	The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other.
>
> **Note 4**:	Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

<hr />

> **11.9.4 The Strict Equals Operator ( === )**
>
> The production EqualityExpression : *EqualityExpression* === *RelationalExpression* is evaluated as follows:
>
> 1. Let *lref* be the result of evaluating EqualityExpression.
> 2. Let *lval* be GetValue(*lref*).
> 3. Let *rref* be the result of evaluating RelationalExpression.
> 4. Let *rval* be GetValue(*rref*).
> 5. Return the result of performing the strict equality comparison *rval* === *lval*. (See 11.9.6)
>

<hr />

> **11.9.5 The Strict Does-not-equal Operator ( !== ) **
>
> The production EqualityExpression : *EqualityExpression* !== *RelationalExpression* is evaluated as follows:
>
> 1. Let *lref* be the result of evaluating EqualityExpression.
> 2. Let *lval* be GetValue(*lref*).
> 3. Let *rref* be the result of evaluating RelationalExpression.
> 4. Let *rval* be GetValue(*rref*).
> 5. Let *r* be the result of performing strict equality comparison *rval* === *lval*. (See 11.9.6)
> 6. If *r* is **true**, return **false**. Otherwise, return **true**.
>

<hr />

> **11.9.6 The Strict Equality Comparison Algorithm**
>
> The comparison *x* === *y*, where *x* and *y* are values, produces **true** or **false**. Such a comparison is performed as follows:
>
> 1. If Type(*x*) is different from Type(*y*), return **false**.
> 2. If Type(*x*) is Undefined, return **true**.
> 3. If Type(*x*) is Null, return **true**.
> 4. If Type(*x*) is Number, then
> 	
> 	1. If *x* is **NaN**, return **false**.
> 	2. If *y* is **NaN**, return **false**.
> 	3. If *x* is the same Number value as *y*, return **true**.
> 	4. If *x* is **+0** and *y* is **−0**, return **true**.
> 	5. If *x* is **−0** and *y* is **+0**, return **true**.
> 	6. Return **false**.
>
> 5. If Type(*x*) is String, then return **true** if *x* and *y* are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return **false**.
>
> 6. If Type(*x*) is Boolean, return **true** if *x* and *y* are both **true** or both **false**; otherwise, return **false**.
>
> 7. Return **true** if *x* and *y* refer to the same object. Otherwise, return **false**.
>
>
> **Note**:	This algorithm differs from the [SameValue Algorithm (9.12)](http://es5.github.io/#x9.12) in its treatment of signed zeroes and NaNs.

  
### BFC

### 0.1 + 0.2
```js
console.log(0.1 + 0.2);
//0.30000000000000004
```

一种解决方案：[math.js](http://mathjs.org/)

另：

> from: [https://www.quora.com/Why-is-0-1+0-2-not-equal-to-0-3-in-most-programming-languages](https://www.quora.com/Why-is-0-1+0-2-not-equal-to-0-3-in-most-programming-languages) & [https://www.reddit.com/r/javascript/comments/2scikz/eli5_why_is_this_true_01_02_030000000000000004/](https://www.reddit.com/r/javascript/comments/2scikz/eli5_why_is_this_true_01_02_030000000000000004/)
> 
> **You don't use equality to compare decimals.**
> 
> Computers use a certain representation to describe decimals. You can google 'floating point representation' to find out more about it, but the idea briefly is that decimals are represented as some value multiplied to a certain power of 2. So 0.75 for example is 3*(2)^-2. However, 0.1 (as is the case for most numbers) doesn't have an accurate representation, and its representation will be that of a number that's very close to 0.1 but not exactly it. It's like trying to represent 1/3 in base 10, you end up writing 0.3333333 which is close to the correct value but still not very accurate.
>
> Now, you want to compare values, you don't use equality. Instead, you compute the absolute difference and make sure that it's very small.
>
> It will be something like that:
> 
> ```js
> const EPS = 1e-6;	//1*10的-6次方。 
> 
> if(Math.abs(0.1 + 0.2 - 0.3) < EPS) {
> 	//true
> }
> ```

<hr />

> In base 10 (decimal), 1/3 is 0.333333... (the 3 repeats)
In base 2 (binary), 1/10 is 0.0001100110011... (the 0011 repeats)
Now, I want you to add 0.33... and 0.33... together. You know from fractions that the answer is 2/3, but if you MUST express it as the infinite numbers. What is more, you MUST only use 32 repeats because you run out of room if you use more. You wind up with

> ```
> 0.33333333333333333333333333333333  (rounding down)
> +0.33333333333333333333333333333333
> ----------------------------------------------
> 0.66666666666666666666666666666666
> ```
> 
> But that answer is wrong (and due to rounding the 3 earlier, we don't even have the 0.666...67 part that most people are used to).
>
> Now let's add 1/10 and 1/10 in binary (remember, 1 + 1 = 10 in binary)
>
> ```
> 0.00011001100110011 (once again we round)
> +0.00011001100110011
> -------------------------
> 0.00110011001100110
> +0.00011001100110011
> -------------------------
> 0.01101110111011101
> ```
> 
> With our rounding error this becomes our infamous 0.3000...4. This is exactly the same thing as rounding those 1/3 numbers in decimal.
> 


### typeof null
> from: [https://stackoverflow.com/questions/18808226/why-is-typeof-null-object](https://stackoverflow.com/questions/18808226/why-is-typeof-null-object)
> 
> ==This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!==


```js
typeof null === 'object'	//true
```

### js let vs var vs const
```js
try {
	var a = 123;
	let b = 123;
	const c = 23;
}catch (e) {
	console.log(e);
}


console.log(a);
console.log(b);	//error
console.log(c);	//error
```
var is scoped to the nearest function block and let is scoped to the nearest enclosing block, which can be smaller than a function block. Both are global if outside any block.

const 必须被初始化。

```js
'use strict';
const a;	// SyntaxError: Missing initializer in const declaration

//************************
'use strict';
let me = 'foo';
let me = 'bar'; // SyntaxError: Identifier 'me' has already been declared

//************************
'use strict';
var me = 'foo';
var me = 'bar'; // No problem, `me` is replaced.

```

### `!!`
> 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其中，第一个逻辑非操作符会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然最终结果与对这个值使用Boolean()函数效果相同。
> 



### 处理HTML5新标签的浏览器兼容问题
当在页面中使用HTML5新标签时，可能会得到三种不同的结果：
1. 新标签被当作错误处理并被忽略，在DOM构建时会当作这个标签不存在。
2. 新标签被当作错误处理，并在DOM构建时，这个新标签会被构造成行内元素。
3. 新标签被识别为HTML5标签，然后用DOM节点对其进行替换。


解决：

1. document.createElement（tagName）
2. html5shim


个人觉得这两个不是很好的解决方案，最好是针对旧浏览器多写一套，之后通过浏览器按需加载。

### 移动端适配方案
移动端适配主要有两大不同的方向：`响应式布局` 和 `自适应布局`。

#### devicepixelratio
*devicepixelratio*(设备像素比，即 dpr) = *physicalpixel* (物理像素) / *density-independent pixel*(设备独立像素，即dip)

在JavaScript中，可以通过 `window.devicePixelRatio` 获取到当前设备的dpr。而在CSS中，可以通过 `-webkit-device-pixel-ratio`，`-webkit-min-device-pixel-ratio` 和 `-webkit-max-device-pixel-ratio` 进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。

dip或dp,（`device independent pixels`，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。

作者：monork
链接：http://www.jianshu.com/p/533117e11498
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### viewpoint
> 暂参见：[http://www.cnblogs.com/2050/p/3877280.html](http://www.cnblogs.com/2050/p/3877280.html)

### addEventListener's third argument
> from: [https://stackoverflow.com/questions/17564323/what-does-the-third-parameter-false-indicate-in-document-addeventlistenerdev](https://stackoverflow.com/questions/17564323/what-does-the-third-parameter-false-indicate-in-document-addeventlistenerdev)

`useCapture `(default: *false*):

If `true`, `useCapture` indicates that the user wishes to initiate capture. After initiating capture, all events of the specified type will be dispatched to the registered `listener` before being dispatched to any `EventTargets` beneath it in the DOM tree. Events which are bubbling upward through the tree will not trigger a listener designated to use capture. See [DOM Level 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow) for a detailed explanation.


如下代码，html 会先捕获到事件，可以在此处设置一个阻断，防止其子元素收到事件：

```js
//<body><div id="div1"></body>
document.body.addEventListener("click", function(e) {
	e.preventDefault();
	e.stopPropagation();
	alert(2);
}, true);

document.getElementById("div1").addEventListener("click", () => {
	alert(1);
}, false);
```


### webpack 合并文件
### webpack version(cache)
### arr.sort 统计
### 事件委派
面试的时候没答上来，还回了一句 event delegate ？结果面试官很开心，然后叫我说说。。后边却又没答出来（不敢说，怕说错丢人。。）。。尴尬，后来引导问了下，原来就是事件冒泡。

一般用在列表型展示的时候，未父元素添加交互事件，这样点击子元素的时候，会冒泡传递到父元素身上，通过 e.target 来确定点击的具体是哪个元素。（具体还可以与 `e.currentTarget` 联动考察考察）

### css top, left 作用
> from: [https://developer.mozilla.org/en-US/docs/Web/CSS/top](https://developer.mozilla.org/en-US/docs/Web/CSS/top)
> 
> The effect of top depends on how the element is positioned (i.e., the value of the position property):
> 
> * When position is set to absolute or fixed, the top property specifies the distance between the element's top edge and the top edge of its containing block.
> * When position is set to relative, the top property specifies the distance the element's top edge is moved below its normal position.
> * When position is set to sticky, the top property behaves like its position is relative when the element is inside the viewport, and like its position is fixed when it is outside.
> * When position is set to static, the top property has no effect.




### css flex-basis vs width
> from: [https://stackoverflow.com/questions/34352140/what-are-the-differences-between-flex-basis-and-width](https://stackoverflow.com/questions/34352140/what-are-the-differences-between-flex-basis-and-width)


### js 放置于 html 文件内的位置
> [https://stackoverflow.com/questions/3531314/should-i-write-script-in-the-body-or-the-head-of-the-html](https://stackoverflow.com/questions/3531314/should-i-write-script-in-the-body-or-the-head-of-the-html)
> 
> [https://www.w3schools.com/js/js_whereto.asp](https://www.w3schools.com/js/js_whereto.asp)
> 
> [https://www.nowcoder.com/questionTerminal/295013c34f7143e0a2c8b37a175764ac](https://www.nowcoder.com/questionTerminal/295013c34f7143e0a2c8b37a175764ac)
> 
> [http://www.jb51.net/article/40741.htm](http://www.jb51.net/article/40741.htm)
> 
> 
> If you don't want your script to be placed inside a function, or if your script should write page content, it should be placed in the body section. Head, or before closure of body tag. When DOM loads JS is then executed, that is exactly what jQuery document.ready does. I always put my scripts in the header.
> 
> 
> Placing scripts at the bottom of the <body> element improves the display speed, because script compilation slows down the display.


### react 兼容性问题

### Array.find vs Array.indexOf
> from: [https://stackoverflow.com/questions/41443029/difference-between-indexof-and-findindex-function-of-array](https://stackoverflow.com/questions/41443029/difference-between-indexof-and-findindex-function-of-array)


### !funciton() {}
> from: [http://blog.dreasgrech.com/2012/09/immediately-invoking-functions-with.html](http://blog.dreasgrech.com/2012/09/immediately-invoking-functions-with.html)




### prototype vs this
这个最近在写一个插件到时候有些困惑，特意理了理。

> from: [https://stackoverflow.com/questions/310870/use-of-prototype-vs-this-in-javascript](https://stackoverflow.com/questions/310870/use-of-prototype-vs-this-in-javascript)



### super
这个也是经常忘记

### flex-basis vs width
这个总是忘记。。

> 待整理: [https://stackoverflow.com/questions/34352140/what-are-the-differences-between-flex-basis-and-width](https://stackoverflow.com/questions/34352140/what-are-the-differences-between-flex-basis-and-width)


### event queue
> 待整理：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)


### promise.all with foreach(), map()
> 待整理：[https://stackoverflow.com/questions/31413749/node-js-promise-all-and-foreach](https://stackoverflow.com/questions/31413749/node-js-promise-all-and-foreach)


### what is mvvm ?

### HTML5为什么只需要写<!DOCTYPE html>
what the f.....fantasy!
HTML5不基于SGML,因此不需要对DTD进行引用，只需要doctype来规范浏览器的行为即可。


### foo.bind(this, xxx)
```js
let foo = (a, b) => {
	console.log(a, b);
};

let fooB = foo.bind(this, "soma data");
dom.addEventListener('click', function (e) {
	fooB(e);
});
// a = "some data"
// b = $event
```


### React 事件实现机制、diff 算法
#### event
> from: [https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html)

### setInterval、setTimeout 实现
### linux 磁盘有空间但提示满，创建不了文件；文件系统
####  inode
> form: [http://www.cnblogs.com/itech/archive/2012/05/15/2502284.html](http://www.cnblogs.com/itech/archive/2012/05/15/2502284.html)


### innodb 与 myisam
> from: [https://dba.stackexchange.com/questions/1/what-are-the-main-differences-between-innodb-and-myisam](https://dba.stackexchange.com/questions/1/what-are-the-main-differences-between-innodb-and-myisam)
> 
> 
> First major difference I see is that InnoDB implements row-level lock while MyISAM can do only a table-level lock. You will find better crash recovery in InnoDB. However, it doesn't have FULLTEXT search indexes until v5.6, as does MyISAM. InnoDB also implements transactions, foreign keys and relationship constraints while MyISAM does not.
>
> The list can go a bit further. Yet, they both have their unique advantages in their favor and disadvantages against each other. Each of them is more suitable in some scenarios than the other.

> So to summarize (TL;DR):

> InnoDB has row-level locking, MyISAM can only do full table-level locking.

> InnoDB has better crash recovery.

> MyISAM has FULLTEXT search indexes, InnoDB did not until MySQL 5.6 (Feb 2013).
> InnoDB implements transactions, foreign keys and relationship constraints, MyISAM does not.
> 

### babel-polyfill
> Babel includes a polyfill that includes a custom regenerator runtime and core.js.
>
> This will emulate a full ES6 environment. This polyfill is automatically loaded when using babel-node and babel/register.



### react context
> from: [https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076](https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076)




### e.target.getAttribute('href') 与 e.target.href

### float right vs absolute
这个很有意思~

> from: [https://kilianvalkhof.com/2008/css-html/absolute-positioning-vs-floats/](https://kilianvalkhof.com/2008/css-html/absolute-positioning-vs-floats/)
> If elements should not interact, use absolute positioning, if they should, use floats. It's that simple. ... The searchform in the top right uses fixed positioning (which mostly behaves like absolute positioning) because it will, and it must, never interact with the other elements on the website.


### slice, substr, substring
这个有时临场写的时候会用到，得记一下。

### rem em
虽然能描述，但还是需要深入了解一下。

### fetch vs xhr
> from: [https://stackoverflow.com/questions/35549547/what-is-the-difference-between-the-fetch-api-and-xmlhttprequest](https://stackoverflow.com/questions/35549547/what-is-the-difference-between-the-fetch-api-and-xmlhttprequest)



### 正则验证
主要是密码处要用，这个之后要系统的学下，先 mark 下：

> from: [https://stackoverflow.com/questions/19605150/regex-for-password-must-be-contain-at-least-eight-characters-at-least-one-numbe](https://stackoverflow.com/questions/19605150/regex-for-password-must-be-contain-at-least-eight-characters-at-least-one-numbe)



### js 判断整数与浮点数
```js
function isInt(n){
    return Number(n) === n && n % 1 === 0;
}

function isFloat(n){
    return Number(n) === n && n % 1 !== 0;
}
```

但是这样有个问题：无法判断 1 与 1.0。个人觉得 js 没有浮点型数据，只能通过转换为字符串后判断 `.` 是否存在。

网上找到的正则：`/(\d+(\.\d+)?)/`


### 浮动
> from: [https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-float.html](https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-float.html)

> [https://juejin.im/entry/580479b85bbb50005b7c5083](https://juejin.im/entry/580479b85bbb50005b7c5083)


### ajax-libraries
一个 ajax 库的比对。
> from: [http://andrewhfarmer.com/ajax-libraries/](http://andrewhfarmer.com/ajax-libraries/)


### 粗略模板实现
审题的时候没审好，其实简单的一个 `replace()` 即可实现。

### 反转二叉树
### 作用域经典
### A 元素绕 B 元素匀速旋转
### requestAnimationFrame 不同设备（电量）帧数平衡问题
### 正则
#### 匹配手机号：
```js
let phone = '18800002002';

phone.match(/^1[3|5|7|8]\d{9}$/)
```

#### 靓号匹配 1xx AABB AABB
```js
let phone = '13488668866';

phone.match(/^1[3|5|7|8][0-9]([0-9]){2}([0-9]){2}\1{2}\2{2}$/);
```

### **页面优化**

### 生成随机数

### iframe 跨域
#### jsonp 手写

### 16 进制转换
```js
let r = Math.random() * 255;

r = r.toString(16);
```

### 根据圆心点求圆上任意点坐标
饼状图需求

### redux 异步
会用得会说


### display
`inline`, `inline-block`, `block`, `flex`, `table`

其中需要特别注意下的就是 `inline`；`table` 我反而基本不用。


### position
主要考的就是 relative 的 top 属性，很容易错。

### javascript 与 native 通信

### 闭包题
写一个函数 add()，每次运行时，打印一个全局计数器。

```js
function add() {}

add();		// 1
add();		// 2
add();		// 3
```

#### 答案
这题有个坑，在于上机的时候，已经写了一个 `function add(){}`，很容易被绕进去。写的时候脑子里一直想的是 this 与 原型；后面知道肯定得用闭包，但是一直想着在 `add` 里面声明 `i`，给面试官一种不够灵性的感觉。。

```js
"use strict";
function a() {
    let i = 1;
    return function () {
        return i++;
    }
}

let add = a();

console.log(add());		// 1
console.log(add());		// 2
```


### 手绘时钟，与系统时间联动
这题其实也还好，花点时间思考下角度就行，由于是上机题，故一直在 jsbin 调试，时间应该在 20 分钟左右。


### http 协议

### repeater
写一个函数，要求：

1. 对一个 foo 循环 n 次
2. 支持传参

展现形式需要自己设计，可以为：

```js
repeater(foo, 100)(param1, pamam2, ...)

repeater(foo, 100, param1, pamam2, ...)
```

### promise 
```js
new Promise(resolve => {
	resolve(1);
	
	Promise.resolve().then(() => console.log(2));
	
	console.log(4);
}).then(t => console.log(t));

console.log(3);
# 4 3 2 1
```

## 自整理
### box-sizing
#### 题目
1. 描述 box-sizing
2. 描述 position: absolute
3. box-sizing 是否影响 absolute 位置

#### 参考
1. https://stackoverflow.com/questions/17115344/absolute-positioning-ignoring-padding-of-parent
2. [https://www.w3.org/TR/CSS21/box.html#padding-edge](https://www.w3.org/TR/CSS21/box.html#padding-edge)
3. [https://www.w3.org/TR/CSS21/visudet.html#containing-block-details](https://www.w3.org/TR/CSS21/visudet.html#containing-block-details)

> When a box has position: absolute its containing box is the parent's padding box (that is, the box around its padding).


### last-child
```html
<ul>
	<li class="selected">1</li>
	<li class="selected">2</li>
	<li>3</li>
</ul>
```

怎样获取第二个 li ？

### fixed with transform
#### 题目
1. parent div 为 `absolute`，child div 为 `fixed`，设置大小后，问 child div 的位置
2. 为 parent div 设置一个 `transform`，然后问此时 child div 位置

#### 参考
> [https://stackoverflow.com/questions/15152712/css-positionfixed-inside-of-positionabsolute](https://stackoverflow.com/questions/15152712/css-positionfixed-inside-of-positionabsolute)
> 
> [https://www.w3.org/TR/css-transforms-1/#transform-rendering](https://www.w3.org/TR/css-transforms-1/#transform-rendering)
> 
> the element with fixed positioning will become relative to the element with the transform - not relative to the viewport.


### 完善 `Function.prototype.bind` 方法
这个笔试题临场没做出来，有点绕。
#### 题目
```js
// 实现 Function 的 bind 方法
function Animal(name, color) {
    this.name = name;
    this.color = color;
}

Animal.prototype.say = function () {
    console.log(this.name + '-' + this.color);
};

let Cat = Animal.bind(null, 'cat');
let cat = new Cat('white');

cat.say() // => 'cat-white'
```

#### 答案
```js
Function.prototype.bind = function (target = null, name) {
	let self = this;
    function Child(color){
        self.call(this, name, color);
    };
    
    Child.prototype = new this();

    return Child;
};
```

### some
简答
1. ES5 / ES6 继承区别
2. 有哪些种实现动画的方式
3. 重放攻击

编程
1. 实现curry函数
    a(1)(2)(3).valueof()
    a(1, 2)(3).valueof()
2. 实现一个能指定优先级的队列
    q.push('优先级 2-1', 0);
    q.push('优先级 1-2', 1);
    q.push('优先级 2-2', 2);
    q.push('优先级 1-1', 3);
    q.dequeue() // 输出 2-2
    q.pop() // 输出 2-1 ?
3. 有n种面额硬币, 指定总额, 给出最小组合

口头
1. 实现双向绑定
2. ssr
3. POST跨大域
4. 浏览器最近有什么新特性


### css 优先级
from: [https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)

> 优先级由低到高：
> 
> 1. **类型选择器**（type selectors）（例如, h1）和 **伪元素**（pseudo-elements）（例如, ::before）
> 2. **类选择器**（class selectors） (例如,.example)，**属性选择器**（attributes selectors）（例如, [type="radio"]），**伪类**（pseudo-classes）（例如, :hover）
> 3. ID选择器（例如, #example）


### HTTP1, HTTP1.1, HTTP2
from: [https://www.cnblogs.com/zhangyfr/p/8662673.html](https://www.cnblogs.com/zhangyfr/p/8662673.html)

#### HTTP1.0和HTTP1.1的一些区别

> HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

> * **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

> * **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

> * **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

> * **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

> * **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

#### HTTP2.0和HTTP1.X相比的新特性

> **新的二进制格式（Binary Format）**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

> **多路复用（MultiPlexing）**，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

> **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

> **服务端推送（server push）**，同SPDY一样，HTTP2.0也具有server push功能。
> 
> 


### toString 和 valueOf有什么区别
#### toString
```javascript
[0,1,2,3] + '';		// or [0,1,2,3].toString();
// 0,1,2,3

let a = {a: 12, v: 21};
a.toString();
// "[object Object]"
```

#### valueOf
需要注意两点：

1. array => self
2. date obj => self.getTime()


```javascipt
[0] === 0
```
	
	
### 千位分隔符

### 从一个无序，不相等的数组中，选取N个数，使其和为M实现算法

### position: absolute 与 unset
#### absolute
相对于 **static** 定位以外的第一个父元素进行定位。

且，默认位置为其基准位置 (元素的 left 和 top 会 按 position = static 时计算)。

![](//blog.azlar.cc/images/frontend_interview/position_absolute.gif)

#### unset
> The `unset` CSS keyword resets a property to its inherited value <u>if it inherits from its parent</u>, and to its initial value if not.
> 


### js GC 回收
from: [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

#### 引用计数垃圾收集
> 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

#### 标记 - 清除算法
> **对象是否不再需要**

解决循环引用问题；限制：无法从根对象查询到的对象都将被清除。



### onmousedown, onfocus, onmouseup, onclick 执行顺序
```javascript
onmousedown => onfocus => onmouseup => onclick
```


### IE浏览器中 attachEvent 方式的事件绑定
> `attachEvent` 的this总是Window。
> 
> ```javascript
> el.attachEvent('onclick', function(){
    alert(this);
} );
> ```
> 


### new == new ?

```javascript
var str = 'asd';
var str2 = new String(str);
var str1 = new String(str);

console.log(str1 == str2 , str1 === str2);
// false false

console.log(str2);
//String {"asd"}
```

### 变量声明
```javascript
function a() { xxx = 123; }

a();

console.log(xxx); 

// 123
// a -> window -> window.xxx = 123
```

### http
> 401.1 未授权：登录失败 （401系列）
> 
> 401.2 未授权：服务器的配置导致登录失败
> 
> 401.3 未授权：由于资源中的 ACL 而未授权 
> 
> 401.4 未授权：授权服务被筛选程序拒绝 
> 
> 401.5 未授权：ISAPI/CGI 应用程序的授权失败 
> 
> 403.1 禁止：禁止执行访问 （403系列）
> 
> 403.2 禁止：禁止读取访问 
> 
> 403.3 禁止：禁止写访问 
> 
> 403.4 禁止：需要 SSL 
> 
> 403.5 禁止：需要 SSL 128 
> 
> 403.6 禁止：拒绝 IP 地址 
> 
> 403.7 禁止：需要用户证书 
> 
> 403.8 禁止：禁止站点访问 
> 
> 403.9 禁止访问：所连接的用户太多 
> 
> 403.10 禁止访问：配置无效 
> 
> 403.11 禁止访问：密码已更改 
> 
> 403.12 禁止访问：映射程序拒绝访问 



### ES5、ES6 继承区别

### 四种常见的 POST 提交数据方式
* application/x-www-form-urlencoded
* multipart/form-data
* application/json
* text/xml


#### multipart
> Summary: if you have binary (non-alphanumeric) data (or a significantly sized payload) to transmit, use multipart/form-data.
> 
>  Otherwise, use application/x-www-form-urlencoded.
> 

```javascript
function multiPost(method, url, formHash){
    var boundary = "nVenJ7H4puv"
    var body = ""
    for(var key in formHash){
        body += "--" + boundary
             + "\r\nContent-Disposition: form-data; name=" + formHash[key].name
             + "\r\nContent-type: " + formHash[key].type
             + "\r\n\r\n" + formHash[key].value + "\r\n"
    }
    body += "--" + boundary + "--\r\n"

    var xml = new XMLHttpRequest();
    xml.open(method, url)
    xml.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary)
    xml.setRequestHeader("Content-Length", body.length)
    xml.send(body)
}
```


### Function.prototype.bind
```javascript
Function.prototype.bind = function () {
    let args = Array.prototype.slice.call(arguments);
    let targetFunc = args.shift();

    let sourceFunc = this;

    let tmpFunc = function() {};

    let newFunc = function() {
        // tmpFunc.call(this);

        args.push.apply(args, arguments);
        return sourceFunc.apply(this instanceof newFunc ? this : targetFunc, args);
    };
	
	if (sourceFunc.prototype) {
	    tmpFunc.prototype = sourceFunc.prototype;
	)
    newFunc.prototype = new tmpFunc();

    return newFunc;
	
	// without new
//    return function () {
//        args.push.apply(args, arguments);
//        return sourceFunc.apply(targetFunc, args);
//    }
}
```


### A.prototype = B.prototype vs A.prototype = new B(), Object.create()
d


### defineProperty
```
let data = new Observer({ a: 1 });

data.on('a', (newValue, oldValue) => {
	console.log(newValue, oldValue);
});

data.a = 2;		// 2, 1

```

### React: diff 机制、检查原理，复杂度
#### batchUpdate
#### setState 的 callback
#### redux middleware 如何实现

#### componentDidCatch
> **error boundaries only catch errors in the components below them in the tree**

#### React.PureComponent
`React.PureComponent` is similar to `React.Component`. The difference between them is that `React.Component` doesn’t implement `shouldComponentUpdate()`, but `React.PureComponent` implements it with a shallow prop and state comparison.

**If your React component’s `render()` function renders the same result given the same props and state, you can use React.PureComponent for a performance boost in some cases.**


> **Note**
> 
> React.PureComponent’s `shouldComponentUpdate()` only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend `PureComponent` when you expect to have simple props and state, or use `forceUpdate()` when you know deep data structures have changed. Or, consider using `immutable objects` to facilitate fast comparisons of nested data.
> 
> Furthermore, `React.PureComponent`’s `shouldComponentUpdate()` skips prop updates for the whole component subtree. Make sure all the children components are also “pure”.
> 

#### React.memo

```javascript
const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});
```



### ssr 实现原理、坑

### Watcher
```js
class Watcher {
  constructor(data) {
    // your code
  }

  $on() {
    // your code
  }
  $emit() {
    // your code
  }
}

const w = new Watcher({a: 1});
w.$on('a', (v) => {
  console.log('first ', v)
})

w.$on('a', (v) => {
  console.log('second ', v)
})

w.a = 2; // console: first 2  second 2

w.$emit('a', 3); // console: first 3  second 3
w.a === 3; // true
```


### 三角形
```css
.triangle {
	border: 27px solid transparent;
	border-bottom-color: #000;
	display: inline-block;
}
```

### event loop


### SSO(Single Sign On)、Oauth2、JWT
单点登录、OAUTH2


#### jwt
无状态问题，通过 decode 与 encode 来实现鉴权。

时效性、刷新 token 是其缺点。

> JWT由于过期数据(exp claim)是封装在Payload中的，所以必须返回一个新Token，而不是在旧Token的基础上刷新。

> 但是在并发的时候也会出现问题，如果前一个请求刷新了Token(为了安全，刷新后一般会把旧Token加入黑名单)，后面的请求使用了一个旧的Token像服务请求数据，这个时候请求会被拒绝。

> 可以说这真的是JWT的一个缺陷，目前没有特别好的办法来解决并发刷新的问题。

> 不过可以通过设置一个宽限时间，在Token刷新后，如果旧Token仍处于刷新宽限时间内，就放行。

#### SSO

### DOM 节点类型
```
元素节点            　　Node.ELEMENT_NODE(1)
属性节点            　　Node.ATTRIBUTE_NODE(2)
文本节点            　　Node.TEXT_NODE(3)
CDATA节点             Node.CDATA_SECTION_NODE(4)
实体引用名称节点    　　 Node.ENTRY_REFERENCE_NODE(5)
实体名称节点        　　Node.ENTITY_NODE(6)
处理指令节点        　　Node.PROCESSING_INSTRUCTION_NODE(7)
注释节点            　 Node.COMMENT_NODE(8)
文档节点            　 Node.DOCUMENT_NODE(9)
文档类型节点        　　Node.DOCUMENT_TYPE_NODE(10)
文档片段节点        　　Node.DOCUMENT_FRAGMENT_NODE(11)
DTD声明节点            Node.NOTATION_NODE(12)
```

### `getElementsByTagNameNS` vs `getElementsByTagName`
`getElementsByTagName('div')` = `getElementsByTagNameNS('http://www.w3.org/1999/xhtml', 'div')`


